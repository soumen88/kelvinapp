// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'game_event.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$GameEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() throwDice,
    required TResult Function() initGame,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? throwDice,
    TResult? Function()? initGame,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? throwDice,
    TResult Function()? initGame,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ThrowDice value) throwDice,
    required TResult Function(_InitGame value) initGame,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ThrowDice value)? throwDice,
    TResult? Function(_InitGame value)? initGame,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ThrowDice value)? throwDice,
    TResult Function(_InitGame value)? initGame,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GameEventCopyWith<$Res> {
  factory $GameEventCopyWith(GameEvent value, $Res Function(GameEvent) then) =
      _$GameEventCopyWithImpl<$Res, GameEvent>;
}

/// @nodoc
class _$GameEventCopyWithImpl<$Res, $Val extends GameEvent>
    implements $GameEventCopyWith<$Res> {
  _$GameEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_ThrowDiceCopyWith<$Res> {
  factory _$$_ThrowDiceCopyWith(
          _$_ThrowDice value, $Res Function(_$_ThrowDice) then) =
      __$$_ThrowDiceCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_ThrowDiceCopyWithImpl<$Res>
    extends _$GameEventCopyWithImpl<$Res, _$_ThrowDice>
    implements _$$_ThrowDiceCopyWith<$Res> {
  __$$_ThrowDiceCopyWithImpl(
      _$_ThrowDice _value, $Res Function(_$_ThrowDice) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_ThrowDice implements _ThrowDice {
  const _$_ThrowDice();

  @override
  String toString() {
    return 'GameEvent.throwDice()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_ThrowDice);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() throwDice,
    required TResult Function() initGame,
  }) {
    return throwDice();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? throwDice,
    TResult? Function()? initGame,
  }) {
    return throwDice?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? throwDice,
    TResult Function()? initGame,
    required TResult orElse(),
  }) {
    if (throwDice != null) {
      return throwDice();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ThrowDice value) throwDice,
    required TResult Function(_InitGame value) initGame,
  }) {
    return throwDice(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ThrowDice value)? throwDice,
    TResult? Function(_InitGame value)? initGame,
  }) {
    return throwDice?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ThrowDice value)? throwDice,
    TResult Function(_InitGame value)? initGame,
    required TResult orElse(),
  }) {
    if (throwDice != null) {
      return throwDice(this);
    }
    return orElse();
  }
}

abstract class _ThrowDice implements GameEvent {
  const factory _ThrowDice() = _$_ThrowDice;
}

/// @nodoc
abstract class _$$_InitGameCopyWith<$Res> {
  factory _$$_InitGameCopyWith(
          _$_InitGame value, $Res Function(_$_InitGame) then) =
      __$$_InitGameCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_InitGameCopyWithImpl<$Res>
    extends _$GameEventCopyWithImpl<$Res, _$_InitGame>
    implements _$$_InitGameCopyWith<$Res> {
  __$$_InitGameCopyWithImpl(
      _$_InitGame _value, $Res Function(_$_InitGame) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_InitGame implements _InitGame {
  const _$_InitGame();

  @override
  String toString() {
    return 'GameEvent.initGame()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_InitGame);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() throwDice,
    required TResult Function() initGame,
  }) {
    return initGame();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? throwDice,
    TResult? Function()? initGame,
  }) {
    return initGame?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? throwDice,
    TResult Function()? initGame,
    required TResult orElse(),
  }) {
    if (initGame != null) {
      return initGame();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ThrowDice value) throwDice,
    required TResult Function(_InitGame value) initGame,
  }) {
    return initGame(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ThrowDice value)? throwDice,
    TResult? Function(_InitGame value)? initGame,
  }) {
    return initGame?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ThrowDice value)? throwDice,
    TResult Function(_InitGame value)? initGame,
    required TResult orElse(),
  }) {
    if (initGame != null) {
      return initGame(this);
    }
    return orElse();
  }
}

abstract class _InitGame implements GameEvent {
  const factory _InitGame() = _$_InitGame;
}
